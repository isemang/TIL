# 조인 종류- 해시 조인, NL조인, 소트머지 조인
+) 이퀴조인, 넌이퀴조인은 →  [여기 참고]([https://hoon93.tistory.com/27](https://hoon93.tistory.com/27))

- 레프트, 라이트, 이너 조인/ 이퀴조인, 넌이퀴조인 → 조건관점
- nl, 소트머지, 해시 → 성능관점

## 1) NL조인(Nested Loops Join)
### 수행 방식
![image](https://user-images.githubusercontent.com/52986346/148916476-fcebb343-52be-4525-bba7-4decf0b6826f.png)
1. 선행 테이블에서 조건을 만족하는 첫 번째 행을 찾는다.<br>
    이 때, 선행 테이블에 주어진 조건을 만족하지 않는 경우, 해당 데이터는 필터링된다.
2. 선행 테이블의 조인 키를 가지고 후행 테이블에 조인 키가 존재하는지 찾으러 간다. (조인을 시도한다)
3. 후행 테이블의 인덱스에 선행 테이블의 조인 키가 존재하는지 확인한다.<br>   
    선행 테이블의 조인 값이 후행 테이블에 존재하지 않으면, 선행 테이블 데이터는 필터링된다. (더 이상 조인 작업을 진행할 필요가 없다)
4. 인덱스에서 추출한 레코드 식별자를 이용하여 후행 테이블을 액세스 한다.<br>
    후행 테이블에 주어진 조건까지 모두 만족하면, 해당 행을 추출 버퍼에 넣는다.
5 ~ 11은 앞의 1 ~ 4 작업을 반복 수행한다.

### 수행 과정에서 알 수 있는 사실
- NL 조인은 프로그래밍 언어에서 사용하는 중첩된 반복문과 유사한 방식으로 조인을 수행한다.

### NL조인의 특징
- 랜덤 액세스(Random Access)방식으로 데이터를 읽는다.
- 랜덤 액세스의 예 : 인덱스 스캔(Index Scan)
    - 즉, 인덱스 스캔은 NL 조인 방식으로 조인을 수행한다!!
- 대량의 데이터를 랜덤 액세스로 접근하게 되면 많은 I/O가 발생해서 성능상 좋지 않기 때문에, 무조건 랜덤 액세스가 좋은게 아니다!!

### 주로 사용되는 곳
- 조인이 성공하면 바로 조인 결과를 사용자에게 보여주기 때문에, 결과를 가능한 빨리 화면에 보여줘야 하는 온라인 프로그램에 적당한 조인 기법이다.

### 다른 조인 기법들과 다른점
- Sort Merge 조인과 Hash 조인은 조인 컬럼의 인덱스가 없어도 사용 가능하다.<br>
    (그림에서 보면, NL조인은 “인덱스”부분이 존재한다)
- NL조인은 메모리에 적재할 수 있는 크기보다 더 커지면 임시 영역(디스크)를 사용한다.

## 2) Sort Merge 조인
### 수행 방식
![image](https://user-images.githubusercontent.com/52986346/148916526-9665bec9-f6e8-4ca9-ae2e-d5947244efed.png)
1. 선행 테이블에서 주어진 조건을 만족하는 행을 찾음.
2. 해당 행들에 대해서, 선행 테이블의 조인 키(칼럼)을 기준으로 데이터를 정렬
3. 후행 테이블에서 주어진 조건을 만족하는 행을 찾음
4. 해당 행들에 대해서, 후행 테이블의 조인 키(칼럼)을 기준으로 데이터를 정렬
5. JOIN을 수행
6. 조인에 성공하면 추출버퍼에 넣는다.

### 주요 특징
- 넓은 범위의 데이터를 처리할 경우, NL 조인은 랜덤 액세스를 이용하기 때문에 매우 부담됨
- 따라서 넓은 범위의 데이터를 처리할 경우 소트 머지 조인을 이용
- 주로 **Full Table Scan** 방식으로 데이터를 읽는 기법
- **소트 머지 조인은 조인 칼럼의 인덱스가 존재하지 않을 경우에도 사용할 수 있다**

### 소트머지조인은 조인 칼럼을 기준으로 데이터를 정렬한 후 조인을 수행한다
- 하지만 조인 작업을 위해 항상 정렬 작업이 발생하는 것은 아님
    - 정렬이 발생하지 않는 예시 : 이미 앞 단계의 작업을 수행하는 도중, 정렬 작업이 미리 수행되었다면, 조인을 위한 정렬 작업은 발생하지 않을 수 있음.
    
### 소트머지조인과 해시조인
- 정렬할 데이터가 많아 메모리에서 모든 정렬 작업을 수행하기 어려운 경우에는 임시 영역(디스크)를 사용 → 성능 저하 발생
- 따라서 CPU 작업 위주로 처리하는 Hash Join이 대량의 정렬 작업이 필요한 소트 머지 조인보다 성능상 유리함
- 해시조인과는 다르게, Equi join 뿐만 아니라 Non-equi 조인에서도 조인 작업이 가능함.

## 3) Hash 조인
### 수행 방식
![image](https://user-images.githubusercontent.com/52986346/148916571-47d0d0e2-ec71-4350-9ddd-3acf4129e56b.png)
1. 선행 테이블에서 주어진 조건을 만족하는 행을 찾음
2. 그 행들에 대해서, **선행 테이블의 조인 키(칼럼)을 기준으로 Hash 함수를 적용**하여 해쉬 테이블을 생성 → **뭔말???**
3. 후행 테이블에서 주어진 조건을 만족하는 행을 찾음
4. 해당 행들에 대해서, 후행 테이블에 Hash함수를 적용하여 선행 테이블의 해쉬 테이블에서 맞는 버킷을 찾음
5. Join을 수행한 후, 조인에 성공하면 추출 버퍼에 넣음
6. 후행 테이블의 조건을 만족하는 모든 행에 대해서 3-5번 반복함

### 주요 특징
- **수행할 테이블의 조인 칼럼을 기준으로 Hash 함수를 적용하여, 서로 동일한 Hash값을 갖는 것들 사이에서 실제 값이 같은지를 비교하면서 조인을 수행**
- 해쉬 함수를 적용한 실제 값은 어떤 값으로 Hashing될지 예측할 수 없지만,해쉬 함수가 적용될 때 동일한 값은 항상 같은 값으로 Hashing됨이 보장됨.
- Hash Join은 동등조인(Equi Join)에서만 사용할 수 있다!!

### 데이터 처리 방식
- Hash Join은 CPU 작업 위주로 데이터를 처리함.
- NL 조인의 **랜덤 액세스** 문제점과 소트 머지 조인의 **정렬 작업** 부담을 해결하기 위한 대안으로 등장

### 해쉬 조인을 사용하면 좋은 곳
- 해쉬 조인은, 조인 작업을 수행하기 위해 “해쉬 테이블”을 메모리에 생성함.
- 따라서, 해쉬 테이블의 크기가 메모리에 적재할 수 있는 크기보다 더 커지면 → 임시영역(디스크)에 해쉬 테이블을 저장함
- 따라서, **Hash Join을 할 때는 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 것**이 좋음!!
- 선행 테이블의 결과를 디스크가 아닌 메모리에 저장할 수 있다면, 임시 영역에 저장하는 작업이 발생하지 않기도 하고, CPU 연산을 조금 덜 수행할 수 있기 때문이다
- Hash Join에서는 선행 테이블을 이용하여 먼저 해쉬 테이블을 생성한다 → 해쉬 선행 테이블을 **”Build Input”** 이라고도 한다.
- 후행테이블은 만들어진 해쉬 테이블에 대해 해쉬 값의 존재여부를 검사한다 → **”Prove Input”** 이라고도 한다.

## 4)NL조인, Sort Merge 조인, Hash 조인의 공통점
- 모두 조인에 성공하면 결과를 **추출버퍼**에 넣는다는 공통점이 있음
- 추출버퍼?
    - 운반단위, Array Size, Prefetch Size라고도 함.
    - SQL문의 실행 결과를 보관하는 버퍼
    - 일정 크기를 설정하여, 추출 버퍼에 결과가 모두 차거나 더 이상 결과가 없어서 추출버퍼를 채울 것이 없으면 결과를 사용자에게 반환함

[참고한 곳들] <br>
[https://bae9086.tistory.com/104](https://bae9086.tistory.com/104) <br>
[https://hoon93.tistory.com/46](https://hoon93.tistory.com/46)
