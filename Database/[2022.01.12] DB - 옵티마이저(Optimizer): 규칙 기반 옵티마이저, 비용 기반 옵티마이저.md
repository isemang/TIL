# 옵티마이저(Optimizer): 규칙 기반 옵티마이저, 비용 기반 옵티마이저
## 1) 옵티마이저란?
#### 가장 효율적인 방법으로 SQL을 수행할 최적의 처리 경로를 생성해주는 DBMS의 핵심 엔진
- 컴퓨터의 두뇌 == CPU, DBMS의 두뇌 == 옵티마이저
- 개발자가 SQL을 작성해서 실행하면, 소프트웨어 실행파일처럼 그냥 즉시 실행되는 게 아니라 옵티마이저에서 "이 쿼리문을 어떻게 실행시키겠다!" 하는 여러 가지 **실행계획**을 세우게 됨

## 2) SQL의 실행 방식
![image](https://user-images.githubusercontent.com/52986346/149051079-403e2161-4c24-451a-9728-0fac780f2722.png)
1. 사용자가 SQL을 작성해서 실행시킨다
2. SQL파서가 SQL을 파싱한다
3. 파싱된 결과가 옵티마이저로 들어가고, 규칙기반 옵티마이저 or 비용기반 옵티마이저에 의해 실행계획이 세워진다<br>
  (비용기반 옵티마이저 작동 시, 딕셔너리에 저장된 통계 데이터를 활용한다)
4. SQL 실행 엔진이 작동하고, 결과를 도출해 사용자에게 보여준다

## 3) 옵티마이저의 종류
|항목|규칙 기반 옵티마이저|비용 기반 옵티마이저|
|:----|:----|:----|
|개념|사전에 정의된 규칙 기반|최소비용을 계산해서 실행계획 수립|
|기준|실행우선 순위(Ranking)|액세스 비용(Cost)|
|인덱스|인덱스 존재 시 제일 우선시해서 실행계획 세움|Cost에 의한 결정|
|성능|사용자 SQL작성 숙련도에 따라 차이남|옵티마이저 예측 성능이 결정함|
|장점|판단이 매우 규칙적이여서 실행 예상이 가능|통계 정보를 통한 현실 요소 적용|
|단점|예측 통계정보 요소 무시|최소 성능 보장 계획의 예측 및 제어가 어려움|
|사례|AND 중심 양쪽 '=' 시 Index Merge 사용|AND 중심 양쪽 '=' 시 분포도별 Index 선택|

## 4) 규칙 기반 옵티마이저(RBO)
- 오라클 8 이하 버전에서 기본으로 설정된 방식
- **실행 속도가 빠른 순으로 규칙을 먼저 세워두고, 우선순위가 앞서는 방법을 채택하는 것**
- 과거에는 옵티마이저의 비용 예측 능력이 좋지 않아 이 방식을 사용했음

### ✔ 규칙 우선순위 리스트
|순위|설명|
|:----|:----|
|1|ROWID를 사용한 단일 행인 경우|
|2|클러스터 조인에 의한 단일 행인 경우|
|3|유일하거나 기본키(Primary Key)를 가진 해시 클러스터 키에 의한 단일 행인 경우|
|4|유일하거나 기본키(Primary Key)에 의한 단일 행인 경우|
|5|클러스터 조인인 경우|
|6|해시 클러스터 조인인 경우|
|7|인덱스 클러스터 키인 경우|
|8|복합 칼럼 인덱스인 경우|
|9|단일 칼럼 인덱스인 경우|
|10|인덱스가 구성된 칼럼에서 제한된 범위를 검색하는 경우|
|11|인덱스가 구성된 칼럼에서 무제한 범위를 검색하는 경우|
|12|정렬-병합(Sort-Merge) 조인인 경우|
|13|인덱스가 구성된 칼럼에서 MAX혹은 MIN을 구하는 경우|
|14|인덱스가 구성된 칼럼에서 Order By를 실행하는 경우|
|15|전체 테이블을 스캔(Full Table Scan)하는 경우|

### ✔ 주요 규칙 설명
- 규칙 1. ROWID를 사용한 단일 행인 경우
  - ROWID를 통해서 테이블에서 하나의 행을 액세스하는 방식
  - ROWID는 행이 포함된 데이터 파일, 블록 등의 정보를 가지고 있기 때문에, 다른 정보를 참조하지 않고도 바로 원하는 행 엑세스 가능
  - 하나의 행을 액세스하는 가장 빠른 방법
- 규칙 4. 유일하거나 기본키(Primary Key)에 의한 단일 행인 경우
  - 유일 인덱스(Unizue Index)를 통해서 하나의 행을 액세스 하는 방식
  - 인덱스를 먼저 액세스하고, 인덱스에 존재하는 ROWID를 추출하여 테이블의 행을 액세스함
- 규칙 8. 복합 칼럼 인덱스인 경우
  - 복합 인덱스에 동등('='연산자) 조건으로 검색하는 경우
  - ex) A+B 칼럼으로 복합 인덱스가 생성되어 있고, 조건절에서 "WHERE A = 10 AND B = 1" 형태로 검색하는 방식
  - 복합 인덱스 사이의 우선 순위 규칙
  - 1. 인덱스 구성 칼럼의 개수가 더 많고 해당 인덱스의 모든 구성 칼럼에 대해 '='로 값이 주어질수록 우선순위가 높음
  - 1번 ex) A+B로 구성된 인덱스와 A+B+C로 구성된 인덱스가 각각 존재하고, 조건절에서 A, B, C 칼럼 모두에 대해 '='로 값이 주어진다면 A+B+C 인덱스가 우선순위가 높음
  - 1번 추가ex) 조건절에서 A, B 칼럼에만 '='로 값이 주어진다면 A+B는 인덱스의 모든 구성 칼럼에 대해 값이 주어지고, A+B+C 인덱스 입장에서는 인덱스의 일부 칼럼에 대해서만 값이 주어졌기 때문에, A+B 인덱스가 우선순위가 높게 됨
- 규칙 9. 단일 칼럼 인덱스인 경우
  - 단일 칼럼 인덱스에 '='조건으로 검색하는 경우
  - ex) A 칼럼에 단일 칼럼 인덱스가 생성되어 있고, 조건절에서 A = 10 형태로 검색
- 규칙 10. 인덱스가 구성된 칼럼에서 제한된 범위를 검색하는 경우
  - 인덱스가 생성되어 있는 칼럼에 한쪽 범위만 한정하는 형태로 검색하는 방식
  - 제한된 범위를 검색하는 연산자 종류에는 >, >=, <, <= 가 있음
  - ex) A 칼럼에 인덱스가 생성되어 있고, A>'10' 또는 A<'20' 형태로 검색하는 방식
- 규칙 15. 전체 테이블을 스캔(Full Table Scan)하는 경우
  - 전체 테이블을 액세스하면서 조건절에 주어진 조건을 만족하는 행만을 결과로 추출

### ✔ 규칙 특징
- 규칙 기반 옵티마이저는 인덱스를 이용한 액세스 방식이 전체 테이블 액세스 방식보다 우선 순위가 높음
- 따라서 규칙 기반 옵티마이저는 SQL문에서 이용 가능한 인덱스가 있다면 무조건 인덱스를 이용하는 방식으로 실행계획을 설계함
- 조인 순서 결정시에는, 조인 칼럼 인덱스의 존재 유무가 중요한 판단 기준이 됨
- 조인 칼럼에 대한 인덱스가 양쪽 테이블에 모두 존재하는 경우
  - 우선 순위가 높은 테이블을 선행 테이블(Driving table)로 선택
- 조인 칼럼에 대한 인덱스가 한쪽에만 존재하는 경우
  - 인덱스가 없는 테이블을 선행 테이블로 선택해서 조인을 수행
- 조인 칼럼에 대한 인덱스가 모두 없는 경우
  - Sort Merge 조인을 사용하고, 둘 중 하나라도 조인 칼럼에 인덱스가 존재한다면 일반적으로 NL조인을 사용함

### ✔ 우선순위 활용 예시
#### [예시 1]
``` SQL
SELECT ENAME FROM EMP WHERE JOB = 'SALESMAN' AND SAL BETWEEN 3000 AND 6000 
INDEX ------ EMP_JOB : JOB EMP_SAL : SAL PK_EMP : EMPNO (UNIQUE)
```
- 조건절에서 JOB칼럼의 조건은 '=', SAL 칼럼의 조건은 'BETWEEN' 으로 주어졌음
- 각각의 칼럼에 단일 칼럼 인덱스가 존재하는 상태
- 우선 순위 규칙에 따라 실행계획을 세우면!
  - JOB조건: 규칙 9의 단일컬럼 인덱스 만족
  - SAL조건: 규칙 10의 인덱스 상의 양쪽 한정 검색 만족<br>
**따라서 우선순위가 높은 EMP_JOB 인덱스를 이용해서 조건을 만족하는 행에 대해  EMP테이블을 액세스**

**예시 1의 실행계획 결과**
``` SQL
Execution Plan ------- 
SELECT STATEMENT Optimizer=CHOOSE TABLE ACCESS (BY INDEX ROWID) OF 'EMP' INDEX (RANGE SCAN) OF 'EMP_JOB' (NON-UNIQUE)
```

### ✔ 규칙 기반 옵티마이저에서 알아둬야 할 점
- 규칙 기반 옵티마이저는 우선순위가 이미 매겨져 있는 상태
- 옵티마이저에서 실행계획이 세워지는 것을 미리 예측할 수 있음<br>
  -> 조금만 응용하면 내가 원하는대로 실행계획 유도 가능
- 하지만 다 좋은 것은 아님, 안좋은 경우 예시
  - 테이블에 데이터가 몇개 없으면 전체 조회 시 Full Table Scan이 유리할 수 있음
  - 그러나 굳이 불필요하게 인덱스를 타버린다던지 하는 비효율적인 방식으로 유도해 버리면
  - 비효율적인 실행 계획이 도출될 수 있음
- 옵티마이저의 실행계획을 유도할 수 있는 **힌트**라던가, Hash Join의 경우<br>
  -> 규칙 기반 옵티마이저 이후에 출시된 개념
  -> 규칙 기반 옵티마이저에서는 힌트와 Hash Join을 사용할 수 없음


## 5) 비용 기반 옵티마이저(CBO)
- 오라클 10 이후부터 공식적으로 사용되는 옵티마이저<br>
  (10부터는 비용 기반 옵티마이저만 사용)
- **옵티마이저에서 최대 2천개까지 실행 계획을 세운 뒤 비용이 최소한으로 나온 실행 계획을 수행함**
- 비용을 예측하기 위해 테이블, 인덱스, 칼럼 등 다양한 객체 통계정보와 시스템 통계정보를 이용함<br>
  (규칙 기반 옵티마이저에서는 이 과정 없음)
- 통계 정보가 없는 경우 비효율적인 실행계획을 생성할 수 있으므로, 정확한 통계정보를 유지하는 것이 중요함

### ✔ 비용 기반 옵티마이저의 모드
- 비용 기반 옵티마이저에는 여러 가지 모드가 있으며, 모드에 따라 최적 비용을 구하는 방식이 조금씩 달라짐
- **CHOOSE**: 현재는 잘 사용하지 않으며, SQL이 실행되는 환경에서 통계 정보를 가져올 수 있을 경우 비용 기반 옵티마이저로, 그렇지 않은 경우 규칙 기반 옵티마이저로 실행
- **FIRST_ROWS**: 옵티마이저가 처리 결과 중 첫 건을 출력하는 데 걸리는 시간을 최소화 할 수 있는 실행 계획을 세우는 모드
- **FIRST_ROWS_n**: SQL의 실행 결과를 출력하는데까지 걸리는 응답속도를 최적화하는 모드
- **ALL_ROWS**: SQL 실행 결과 전체를 빠르게 처리하는 데 최적화 된 실행계획을 세우는 모드<br>
  마지막으로 출력될 행까지 최소한의 자원을 사용하여 최대한 빨리 가져오게 하며, 오라클 10g 이후로는 이 모드가 기본값으로 설정됨

### ✔ 비용 기반 옵티마이저의 동작 방식
![image](https://user-images.githubusercontent.com/52986346/149058395-883e9b86-c74b-43f9-8b19-120d50c6c153.png)
1. Parser: SQL 문장을 분석하여 문법 검사와 구성요소를 파악하고 이를 파싱해서 파싱 트리를 만든다
2. Query Transformer: 파싱된 SQL을 보고 같은 결과를 도출하되, 좀 더 나은 실행 계획을 갖는 SQL로 변환이 가능한지를 판단하여 변환 작업을 수행
3. Estimator: 시스템 통계 정보를 딕셔너리로부터 수집하여 SQL을 실행할 때 소요되는 총 비용을 계산한다
4. Plan Generator: Estimator를 통해 계산된 값들을 토대로 후보군이 되는 실행 계획을 도출한다
5. Row-Source Generator: 옵티마이저가 생성한 실행계획을 SQL엔진이 실제 실행할 수 있는 코드나 프로시저 형태로 포맷팅 한다
6. SQL Engine: SQL을 실행한다

### ✔ 동작 방식 상세 : Query Transformer, Estimator, Plan Generator
![image](https://user-images.githubusercontent.com/52986346/149060512-45f570c9-c35f-43a3-9663-c724092179ef.png)
- Query Transformer: 질의 변환기, Estimator: 비용 예측기, Plan Generator: 대안 계획 생성기
1. 질의 변환기
  - 사용자가 작성한 SQL문을 처리하기에 보다 용이한 형태로 변환하는 모듈
2. 대안 계획 생성기
  - 동일한 결과를 생성하는 다양한 대안 계획을 생성하는 모듈
  - 연산의 적용 순서 변경, 연산 방법 변경, 조인 순서 변경 등을 통해서 생성됨
  - 동일한 결과를 생성하는 가능한 모든 대안 계획을 생성해야 보다 나은 최적화를 수행 가능
  - 그렇지만 또 너무 많은 대안 계획을 생성 하다보면 시간이 오래걸림 -> 대안 계획 수 제약하는 방법 사용
  - 현실적인 제약으로 인해 생성된 대안 계획 중 최적의 대안 계획이 포함되지 않을 수 있음
3. 비용 예측기
  - 대안 계획 생성기에 의해서 생성된 대안 계획의 비용을 예측하는 모듈
  - 대안 계획의 정확한 비용 예측을 위해, 연산의 중간 집합의 크기 및 결과 집합의 크기, 분포도 등의 예측이 정확해야 함
4. **딕셔너리**
  - 실행 계획 예상 비용 산정 시 필요한 각종 오브젝트 통계 및 시스템 통계정보를 미리 수집해놓은 곳
  - 이러한 통계정보는 꾸준히 갱신되는 것이 중요함
  - 주요 통계 정보들
  ![image](https://user-images.githubusercontent.com/52986346/149061448-b3c96b87-cce3-4cad-8e5a-0827db2323c2.png)

### ✔ 비용 기반 옵티마이저 실제 동작 예시
![image](https://user-images.githubusercontent.com/52986346/149061665-1e14d7ec-6aca-46ca-b317-99084cb061ba.png)
- 후보군이 될만한 실행계획을 찾고, 각 비용을 비교해서 최저비용을 갖는 하나를 선택한다




___
[참고한 곳]<br>
https://coding-factory.tistory.com/743  <br>
http://wiki.gurubee.net/pages/viewpage.action?pageId=26740819  <br>
https://dataonair.or.kr/db-tech-reference/d-guide/sql/?mod=document&uid=354
 


