# 4장. 아키텍처
## 4.1 MySQL 엔진 아키텍처
- 사람의 머리 역할을 담당하는 "MySQL 엔진" 과 손발 역할을 담당하는 "스토리지 엔진"으로 구분할 수 있다
- MySQL엔진: 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 ①커넥션 핸들러와 ②SQL 파서 및 ③전처리기, 쿼리의 최적화된 실행을 위한 ④옵티마이저가 중심을 이룬다.
- 스토리지 엔진: 실제 데이터를 디스크 스토리지에 저장하거나, 디스크 스토리지로부터 데이터를 읽어오는 부분을 말한다
- 핸들러 API: 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기 요청을 하게 되고, 이러한 "요청"을 할 때 사용하는 API를 말한다.
- MySQL 서버는 프로세스 기반이 아닌, 스레드 기반으로 작동
  - 포그라운드 스레드(클라이언트 스레드): 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
  - 백그라운드 스레드: 버퍼풀의 데이터를 디스크에 기록하고, 데이터를 버퍼로 읽어오는 등 InnoDB에서는 여러 작업들이 백그라운드로 처리된다
    > 사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있다.
    > 그래서 일반적인 상용 DBMS에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재되어 있다.
- MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분됨
  - 글로벌 메모리 영역: MySQL서버가 시작되면서 운영체제로부터 할당되는 영역
  - 로컬 메모리 영역: 클라이언트 스레드가 쿼리를 처리한는데 사용하는 영역
- MySQl 8.0버전부터, 기존의 플러그인 아키텍처의 단점을 보완하기 위해 컴포넌트 아키텍처가 지원된다
  - 플러그인끼리 통신 불가능, 오직 MySQL서버와만 인터페이싱
  - 플러그인은 서버의 변수나 함수를 직접 호출한다(캡슐화가 안된다)
  - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어렵다
- 쿼리 실행구조
  - 쿼리 파서: 쿼리 문장을 토큰으로 분리하여 트리 구조로 만든다
  - 전처리기: 트리 구조의 쿼리가 구조적 문제가 있는지 확인한다
  - 옵티마이저: 쿼리가 실행될 때, 어떻게 실행해야 가장 저렴한 비용으로 실행될지 고민한다 (DBMS의 두뇌)
  - 실행 엔진: 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다
  - 핸들러(스토리지 엔진): MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할을 한다
  - 쿼리캐시: 동일한 SQL쿼리가 실행되면, 테이블을 읽지 않고 즉시 반환해서 빠른 성능을 낸다. 하지만 이로 인한 버그가 자주 발생하기 때문에, **MySQL 8.0 버전부터는 제거되었다**

## 4.2 InnoDB 스토리지 엔진 아키텍처
