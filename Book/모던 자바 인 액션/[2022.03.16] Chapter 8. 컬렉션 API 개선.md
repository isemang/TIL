# Chapter 8. 컬렉션 API 개선
## ※ 주요 내용
### 컬렉션 API 중 자바 8, 9에서 추가된 신규 기능 소개
- 컬렉션 팩토리
  - 크기가 작은 List, Set, Map을 쉽게 만들 수 있는 방법 소개
- 관용 패턴: 다양한 신규 메서드 추가
  - 자바 8의 개선 사항
  - List, Set, Map에서 요소를 삭제하거나 바꾸는 메서드 소개
- 개선된 ConcurrentHashMap

## 8-1. 컬렉션 팩토리
- 자바 9에서 신규 제공
- 적은 개수의 요소를 추가하고자 할 때 유용하다
## 1. 기존방식들로 컬렉션에 적은 개수의 요소 추가하기
### 1) List
### ✔️ 단순 코드 작성
```java
List<String> friends = new ArrayList<>();
friends.add("Raphael");
friends.add("Olivia");
friends.add("Thibaut");
```
-> 단순 추가임에도 코드가 많이 필요하다

### ✔️ Arrays.asList() 이용
```java
List<String> friends = Arrays.asList("Raphael", "Olivia", "Thibaut");
```
- 고정 크기이므로, 요소를 갱신할 수는 있지만 **추가할 수는 없다**
- 요소 추가 시 **UnsupportedOperationException** 발생

### 2) Set
### ✔️ 리스트를 인수로 받는 HashSet 생성자 사용
```java
Set<String> friends = new HashSet<>(Arrays.asList("Raphael", "Olivia", "Thibaut"));
```

### ✔️ Stream API 사용
```java
Set<String> friends = Stream.of("Raphael", "Olivia", "Thibaut").collect(Collectors.toSet());
```

### ✔️ 두 방법 모두 별로 추천하지 않음
- 매끄럽지 못한 방식
- 내부적으로 불필요한 객체 할당을 필요로 함

### 3) Map
### ✔️ 단순 코드 작성
```java
Map<String< Integer> friends = new HashMap<>();
friends.add("Raphael", 1);
friends.add("Olivia", 2);
friends.add("Thibaut", 3);
```

## 2. 팩토리 메서드로 컬렉션에 적은 개수의 요소 추가하기
### 1) List Factory
- **List.of 팩토리 메소드를 이용해서 간단하게 리스트를 만들 수 있다**
```java
List<String> friends = List.of("Raphael", "Olivia", "Thibaut");
System.out.println(friends);  //[Raphael, Olivia, Thibaut]
```
- 이미 정의된 List에 요소 신규 추가 불가: UnsupportedOperationException 발생
```java
List<String> friends = List.of("Raphael", "Olivia", "Thibaut");
friends.add("Chih-Chun");     // 불가능, UnsupportedOperationException 발생
```
-> 컬렉션이 의도치 않게 변하는 것을 막을 수 있기 때문에, 오히려 좋다<br>
-> 요소 자체의 변경은 막을 수 없음<br>

- 신규 추가된 List.of를 가변 배열 메서드로 만들지 않은 이유
  - 가변 배열의 내부 구현에 해답이 있음
  - 가변 인수 버전은 추가 배열을 할당해서 리스트로 감싼다
  - 따라서 배열을 할당하고, 초기화하며 나중에 가비지 컬렉션을 하는 비용을 지불해야 한다
  - 고정되어있도록 API를 정의하면, 이러한 추가비용을 제거할 수 있음

### 2) Set Factory
```java
Set<String> friends = Set.of("Raphael", "Olivia", "Thibaut");
System.out.println(friends);  //[Raphael, Olivia, Thibaut]
```

- List Factory와 마찬가지로 이미 정의된 Set에 요소 신규 추가 불가
```java
Set<String> friends = Set.of("Raphael", "Olivia", "Thibaut");
friends.add("Chih-Chun");     // 불가능, UnsupportedOperationException 발생
```

- 중복 요소 추가 불가: IllegalArgumentException 발생
```java
Set<String> friends = Set.of("Raphael", "Olivia", "Olivia");  // 불가능, IllegalArgumentException 발생
```

### 3) Map Factory
- Map.of 팩토리 메서드에 키와 값을 번갈아 제공하는 방법으로 맵 생성 가능<br>
-> 열 개 이하의 맵에서 유용
```java
Map<String, Integer> ageOfFriends = Map.of("Raphael", 30, "Olivia", 25, "Thibaut", 26);
System.out.println(friends);  //[Raphael=30, Olivia=25, Thibaut=26]
```

- 열 개 초과의 맵에서는<br>
-> Map.Entry<K, V> 객체를 인수로 받으며 가변 인수로 구현된 **Map.ofEntries** 팩토리 메서드를 이용하는 것이 좋다
```java
import static java.util.Map.entry;    //Map.entry: Map.Entry 객체를 만드는 새로운 팩토리 메서드

Map<String, Integer> ageOfFriends = Map.ofEntries("Raphael", 30, "Olivia", 25, "Thibaut", 26);
System.out.println(friends);  //[Raphael=30, Olivia=25, Thibaut=26]
```

## 8-2. List와 Set에서의 신규 메서드 소개
## 1. 간략 소개
- removeIf
  - 프레디케이트를 만족하는 요소를 제거
  - List나 Set을 구현하거나, 그 구현을 상속받은 모든 클래스에서 이용 가능
- replaceAll
  - List에서 이용 가능한 기능
  - UnaryOperator 함수를 이용해 요소를 바꾼다
- sort
  - List 인터페이스에서 제공하는 기능
  - 리스트 정렬 시 사용

## 2. 신규 메서드 도입의 이유
- 세 가지 메서드 모두 호출한 컬렉션 자체를 바꿈(기존 컬렉션을 바꾼다)
- 컬렉션을 바꾸는 동작은 에러를 유발하고, 복잡함을 더함
- 신규 메서드를 사용하여 컬렉션 변경 시의 복잡함을 줄일 수 있음

## 3. 메서드 상세
### 1) removeIf 메서드
- 요소를 **제거**하는 코드
- List, Set 모두에서 사용 가능
### ※ 예제 코드 : 숫자로 시작되는 참조 코드를 가진 트랜잭션을 삭제
### ✔️ 기존 방식
```java
for (Transaction transaction : transactions) {
  if(Character.isDigit(transaction.getReferenceCode().charAt(0))) {
    transaction.remove(transaction);
  }
}
```
-> ConcurrentModificationException을 유발함

- 위의 코드가 Exception을 일으키는 이유
```java
/** 위의 코드와 같음 **/
for (Iterator<Transaction> iterator = transactions.iterator();
    iterator.hasNext(); ) {
  Transaction transaction = iterator.next();
  if(Character.isDigit(transaction.getReferenceCode().charAt(0))) {
    transaction.remove(transaction);  // 문제발생요인: 반복하면서 별도의 두 객체를 통해 컬렉션을 바꾼다.
  }
}
```
-> 두 개의 개별 객체가 컬렉션을 관리한다.
  1. Iterator 객체: next()와 hasNext()를 이용해 소스를 질의함
  2. Collection 객체 자체: remove()를 호출해 요소를 삭제함<br>
-> 결과적으로, **반복자의 상태는 컬렉션의 상태와 서로 동기화되지 않음**

- Iterator 객체를 명시적으로 사용하고, 그 객체의 remove()메서드를 호출하면서 문제 해결 가능
```java
for (Iterator<Transaction> iterator = transactions.iterator();
    iterator.hasNext(); ) {
  Transaction transaction = iterator.next();
  if(Character.isDigit(transaction.getReferenceCode().charAt(0))) {
    iterator.remove();    // iterator객체의 remove()메서드를 호출해 문제를 해결했다
  }
}
```

### ✔️ removeIf 메서드
- removeIf메서드를 이용하면 코드가 단순해 질 뿐 아니라 버그도 예방할 수 있음
- 삭제할 요소를 가리키는 프레디케이트를 인수로 받음
```java
transactions.removeIf(transaction ->
    Character.isDigi(transaction.getReferenceCode().charAt(0)));
```

### 2) replaceAll 메서드
- 요소를 **바꾸는**코드
- List 인터페이스 에서만 사용 가능
### ※ 예제 코드: 문자열 List의 소문자값 대문자로 변경
### ✔️ 스트림 API를 사용할 때
```java
referenceCodes.stream() //[a12, C14, b13]
            .map(code -> Character.toUpperCase(code.charAt(0)) + code.substring(1))
            .collect(Collectors.toList())
            .forEach(System.out::println);  // A12, C14, B13
```
-> 새 문자열 컬렉션을 만드는 코드임<br>
-> 우리가 원하는 건 새 컬렉션 생성이 아닌 **기존 컬렉션 변경**

- ListIterator객체(요소를 바꾸는 set()메서드 지원) 이용
```java
for (ListIterator<String> iterator = referenceCodes.listIterator();
    iterator.hasNext(); ) {
    String code = iterator.next();
    iterator.set(Character.toUpperCase(code.charAt(0)) + code.substring(1));
}
```
-> removeIf에서 설명한 것처럼, 컬렉션 객체를 Iterator객체와 혼용하면 쉽게 문제를 일으킴
  (반복과 컬렉션 변경이 동시에 이루어지기 때문)

### ✔️ replaceAll 메서드
```java
referenceCodes.replaceAll(code -> Character.toUpperCase(code.charAt(0)) + code.substring(1));
```

# 8-3. Map에서의 신규 메서드 소개


