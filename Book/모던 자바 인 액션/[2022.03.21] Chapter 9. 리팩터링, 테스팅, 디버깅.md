# Chapter 9. 리팩터링, 테스팅, 디버깅
## ※ 주요 내용
### 람다 표현식으로 가독성과 유연성을 높이는 방법 소개
- 기존 코드를 람다식으로 리팩터링하기
- 람다 표현식으로 객체지향 디자인 패턴(전략, 템플릿 메서드, 옵저버 등..) 간소화시키는 법 소개
- 람다 표현식과 스트림 API를 사용하는 코드를 테스트하고, 디버깅하는 방법 소개

## 9-1. 가독성과 유연성을 개선하는 리팩터링
- 람다의 동작 파라미터화 형식을 이용해 코드 유연성을 높일 수 있다
### 1. 코드 가독성 개선
- 익명 클래스를 람다 표현식으로 리팩터링하기
- 람다 표현식을 메서드 참조로 리팩터링하기
- 명령형 데이터 처리를 스트림으로 리팩터링하기

### 2. 익명 클래스를 람다 표현식으로 리팩터링하기
- 익명 클래스를 람다 표현식으로 리팩터링 하는 이유?
  - 익명 클래스는 코드를 장황하게 만든다
  - 장황항 코드는 에러를 일으키기 쉽다
  - 람다 표현식을 사용하면 익명 클래스보다 훨씬 더 간결하고, 가독성이 좋은 코드를 구현할 수 있다

### ✔️ 예시 코드: Runnable 익명클래스 사용
① 익명 클래스 사용
```java
Runnable r1 = new Runnable() {
    public void run() {
        System.out.println("hello");
    }
};
```
② 람다 표현식 사용
```java
Runnable r2 = () -> System.out.println("hello");
```

### ✔️ 익명 클래스를 람다 표현식으로 변환할 수 없는 경우
- 익명 클래스에서 사용한 this와 super는 람다 표현식에서 다른 의미를 가짐
  - 익명 클래스의 this: 익명 클래스 자신
  - 람다 표현식의 this: 람다를 감싸는 클래스
- 섀도 변수 가능여부
  - 익명 클래스는 감싸고 있는 클래스의 변수를 가릴 수 있음
  - 람다 표현식은 변수를 가릴 수 없음
이 코드는 에러가 나지만
```java
int a = 10;
Runnable r1 = () -> {
    int a = 2;  //컴파일 에러
    System.out.println(a);
};
```
이 코드는 에러가 나지 않는다
```java
int a = 10;
Runnable r2 = new Runnable() {
    public void run() {
        int a = 2;  //에러 X, 잘 작동함
        System.out.println(a);
    }
};
```
- 콘텍스트 오버로딩의 모호함이 존재함
  - 익명 클래스를 람다 표현식으로 바꾸면 콘텍스트 오버로딩에 따른 모호함이 초래될 수 있음
  - 익명 클래스는 인스턴스화할 때 명시적으로 형식이 정해짐
  - 람다 표현식의 형식은 콘텍스트에 따라 달라짐<br>

예제 코드: Runnable과 같은 특징을 지닌 함수형 인터페이스 'Task' 선언
```java
interface Task {
    public void execute();
}
public static void doSomething(Runnable r) {
    r.run();
}
public static void doSomething(Task a) {
    a.execute();
}
```
Task를 구현하는 익명 클래스를 전달할 수 있음
```java
doSomething(new Task() {
    public void execute() {
        System.out.println("Danger danger!!");
    }
});
```
하지만 익명 클래스를 람다 표현식으로 바꾸면 문제가 발생함<br>
-> 메서드를 호출할 때, Runnable과 Task 둘 중 어느걸 가리키는지 모호해진다
```java
doSomething(() -> System.out.println("Danger danger!!"));
```
-> doSomething(Runnable)을 가리키는지, doSomething(Task)를 가리키는지 알 수 없다<br><br>

Task로의 명시적 형변환을 이용해 모호함을 제거할 수 있다
```java
doSomething((Task)() -> System.out.println("Danger danger!!"));
```

### 3. 람다 표현식을 메서드 참조로 리팩터링하기
- 람다 표현식도 충분히 짧지만, 메서드 참조를 이용하면 가독성을 더 높일 수 있다
### ✔️ 예시 코드: 칼로리 수준으로 요리를 그룹화하는 코드
```java
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel =
      menu.stream()
          .collect(
                  groupingBy(dish -> {
                      if (dish.getCalories() <= 400) return CaloricLevel.DIET;
                      else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
                      else return CaloricLevel.FAT;
}));
```

### 4. 명령형 데이터 처리를 스트림으로 리팩터링하기

### 5. 코드 유연성 개선

## 9-2. 람다로 객체지향 디자인 패턴 리팩터링하기
### 1. 전략(Strategy) 패턴

### 2. 템플릿 메서드 패턴

### 3. 옵저버 패턴

### 4. 의무 체인 패턴

### 5. 팩토리 패턴

## 9-3. 람다 테스팅
### 1. 보이는 람다 표현식의 동작 테스팅

### 2. 람다를 사용하는 메서드의 동작에 집중하라

### 3. 복잡한 람다를 개별 메서드로 분할하기

### 4. 고차원 함수 테스팅

## 9-4. 디버깅
### 1. 스택 트레이스 확인

### 2. 정보 로깅

