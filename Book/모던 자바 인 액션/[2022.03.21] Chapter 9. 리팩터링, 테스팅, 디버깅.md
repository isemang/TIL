# Chapter 9. 리팩터링, 테스팅, 디버깅
## ※ 주요 내용
### 람다 표현식으로 가독성과 유연성을 높이는 방법 소개
- 기존 코드를 람다식으로 리팩터링하기
- 람다 표현식으로 객체지향 디자인 패턴(전략, 템플릿 메서드, 옵저버 등..) 간소화시키는 법 소개
- 람다 표현식과 스트림 API를 사용하는 코드를 테스트하고, 디버깅하는 방법 소개

## 9-1. 가독성과 유연성을 개선하는 리팩터링
- 람다의 동작 파라미터화 형식을 이용해 코드 유연성을 높일 수 있다
### 1. 코드 가독성 개선
- 익명 클래스를 람다 표현식으로 리팩터링하기
- 람다 표현식을 메서드 참조로 리팩터링하기
- 명령형 데이터 처리를 스트림으로 리팩터링하기

### 2. 익명 클래스를 람다 표현식으로 리팩터링하기
- 익명 클래스를 람다 표현식으로 리팩터링 하는 이유?
  - 익명 클래스는 코드를 장황하게 만든다
  - 장황항 코드는 에러를 일으키기 쉽다
  - 람다 표현식을 사용하면 익명 클래스보다 훨씬 더 간결하고, 가독성이 좋은 코드를 구현할 수 있다

### ✔️ 예시 코드: Runnable 익명클래스 사용
① 익명 클래스 사용
```java
Runnable r1 = new Runnable() {
    public void run() {
        System.out.println("hello");
    }
};
```
② 람다 표현식 사용
```java
Runnable r2 = () -> System.out.println("hello");
```

### ✔️ 익명 클래스를 람다 표현식으로 변환할 수 없는 경우
- 익명 클래스에서 사용한 this와 super는 람다 표현식에서 다른 의미를 가짐
  - 익명 클래스의 this: 익명 클래스 자신
  - 람다 표현식의 this: 람다를 감싸는 클래스
- 섀도 변수 가능여부
  - 익명 클래스는 감싸고 있는 클래스의 변수를 가릴 수 있음
  - 람다 표현식은 변수를 가릴 수 없음<br><br>
이 코드는 에러가 나지만
```java
int a = 10;
Runnable r1 = () -> {
    int a = 2;  //컴파일 에러
    System.out.println(a);
};
```
이 코드는 에러가 나지 않는다
```java
int a = 10;
Runnable r2 = new Runnable() {
    public void run() {
        int a = 2;  //에러 X, 잘 작동함
        System.out.println(a);
    }
};
```
- 콘텍스트 오버로딩의 모호함이 존재함
  - 익명 클래스를 람다 표현식으로 바꾸면 콘텍스트 오버로딩에 따른 모호함이 초래될 수 있음
  - 익명 클래스는 인스턴스화할 때 명시적으로 형식이 정해짐
  - 람다 표현식의 형식은 콘텍스트에 따라 달라짐<br>

예제 코드: Runnable과 같은 특징을 지닌 함수형 인터페이스 'Task' 선언
```java
interface Task {
    public void execute();
}
public static void doSomething(Runnable r) {
    r.run();
}
public static void doSomething(Task a) {
    a.execute();
}
```
Task를 구현하는 익명 클래스를 전달할 수 있음
```java
doSomething(new Task() {
    public void execute() {
        System.out.println("Danger danger!!");
    }
});
```
하지만 익명 클래스를 람다 표현식으로 바꾸면 문제가 발생함<br>
-> 메서드를 호출할 때, Runnable과 Task 둘 중 어느걸 가리키는지 모호해진다
```java
doSomething(() -> System.out.println("Danger danger!!"));
```
-> doSomething(Runnable)을 가리키는지, doSomething(Task)를 가리키는지 알 수 없다<br><br>

Task로의 명시적 형변환을 이용해 모호함을 제거할 수 있다
```java
doSomething((Task)() -> System.out.println("Danger danger!!"));
```

### 3. 람다 표현식을 메서드 참조로 리팩터링하기
- 람다 표현식도 충분히 짧지만, 메서드 참조를 이용하면 가독성을 더 높일 수 있다
### ✔️ 예시 코드: 칼로리 수준으로 요리를 그룹화하는 코드
```java
Map<CaloricLevel, List<Dish>> dishesByCaloricLevel =
      menu.stream()
          .collect(
                  groupingBy(dish -> {
                      if (dish.getCalories() <= 400) return CaloricLevel.DIET;
                      else if (dish.getCalories() <= 700) return CaloricLevel.NORMAL;
                      else return CaloricLevel.FAT;
}));
```
- 람다 표현식을 별도의 메서드로 추출한 다음, groupingBy에 인수로 전달할 수 있음<br>
  -> 코드가 간결하고 의도도 명확해짐
```java
Map<CaloricLevel, List<Dish>> dishesByCaloricLevelA =
            menu.stream().collect(groupingBy(Dish::getCaloricLevel));   //람다 표현식을 메서드로 추출했다
```

- Dish class에 getCaloricLevel메서드를 추가
```java
public class Dish {
    ...
    public CaloricLevel getCaloricLevel() {
        if (this.getCalories() <= 400) return CaloricLevel.DIET;
        else if (this.getCalories() <= 700) return CaloricLevel.NORMAL;
        else return CaloricLevel.FAT;
    }
}
```

- 정적 헬퍼 메서드 적극 활용: comparing, maxBy <br>
  -> 메서드 참조와 조화를 이루도록 설계되었기 때문에, 이를 활용하면 코드의 의도를 명확하게 보여줄 수 있다
```java
inventory.sort(
    (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));  //비교 구현에 신경써야 한다.
inventory.sort(comparing(Apple::getWeight));    //코드가 문제 자체를 설명한다
```
- 저수준 리듀싱 연산을 조합한 코드<br>
  -> 저수준 리듀싱 연산????????
```java
int totalCalories =
      menu.stream().map(Dish::getCalories)
                   .reduce(0, (c1, c2) -> c1 + c2);
```

- 내장 컬렉터 이용(summingInt 사용)<br>
  -> 내장 컬렉터????????????????
```java
int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));
```

### 4. 명령형 데이터 처리를 스트림으로 리팩터링하기
- 이론적으로는, 반복자(for문 등..)를 이용한 기존의 모든 컬렉션 처리 코드를 스트림 API로 바꿔야 함
  - 스트림 API가 데이터 처리 파이프라인의 의도를 더 명확하게 보여주기 때문
  - 쇼트서킷과 게으름(lazy)이라는 강력한 최적화를 가지고 있기 때문
  - 멀티코어 아키텍처를 쉽게 활용할 수 있기 때문
### ✔️ 예시 코드: 필터링과 추출, 두 가지 패턴으로 엉킨 코드
- 병렬로 실행히키기 어려우며, 가독성이 떨어진다
```java
List<String> dishNames = new ArrayList<>();
for (Dish dish : menu) {
    if (dish.getCalories() > 300) {
        dishNames.add(dish.getName());
    }
}
```
- 스트림 API를 이용하면 병렬화도 쉬워지고 가독성도 올라간다
```java
menu.parallelStream()
    .filter(d -> d.getCalories() > 300)
    .map(Dish::getName)
    .collect(toList());
```

### 5. 코드 유연성 개선
- 람다 표현식을 이용하면 동작 파라미터화를 쉽게 구현할 수 있기 때문에, 변화하는 요구사항에 대응 가능한 코드를 작성할 수 있다
- ex) 보안 검사, 로깅 관련 코드

### 1) 조건부 연기 실행
조건부 ㄷ연기 실행이 뭔말임 ....??????????????
### ✔️ 예시 코드: 내장 자바 Logger 클래스 관련 코드
```java
if (logger.isLoggable(Log.FINER)) {
    logger.finer("Problem: " + generateDiagnostic());
}
```
- 위 코드가 문제인 이유
  - logger의 상태가 isLoggable이라는 메서드에 의해 클라이언트 코드로 노출됨
  - 불필요한 로직 존재 : 메시지로 로딩할때마다 logger 객체의 상태를 매번 확인

- 메시지를 로깅하기 전에, logger객체가 적절한 수준으로 설정되었는지 내부적으로 확인하는 log 메서드를 사용하는 것이 바람직하다
```java
logger.log(Level.FINER, "Problem: " + generateDiagnostic());
```
- 위 코드의 장점
  - 불필요한 if문 제거 가능
  - logger의 상태가 노출되지 않음
- 위 코드의 단점
  - 인수로 전달된 메시지 수준에서 logger가 활성화되어 있지 않더라도 항상 로깅 메시지를 평가하게 됨<br>
  -> 람다를 이용해 해당 문제를 해결 가능

- 자바8 에서는 위읙 문제를 해결할 수 있도록 Supplier를 인수로 갖는 오버로드된 log메서드를 제공함
```java
public void log(Level level, Supplier<String> msgSupplier)
```
- 위의 메서드를 활용한 log메서드 호출
```java
logger.log(Level.FINER, () -> "Problem: " + generateDiagnostic());
```
- log 메서드의 내부 구현 코드를 보면, logger의 수준이 적절하게 설정되어 있을 때만 인수로 넘겨진 람다를 내부적으로 실행한다
```java
public void log(Level level, Supplier<String> msgSupplier){
    if (logger.isLoggable(level)) {
        log(level, msgSupplier.get());  //람다 실행
    }
}
```
- p.300에 무슨 내용 어쩌고저쩌고 적혀있는데... 뭔말인지 모르겠음 ㅜㅜㅜ

### 2) 실행 어라운드
- 반복적으로 수행하는 코드를 람다로 변환하여, 로직을 재사용하는 패턴
- 로직의 재사용으로 코드 중복을 줄일 수 있음
### ✔️ 예시 코드: 파일 처리 코드
- 기존에는 파일을 열고 닫을 때 같은 로직을 사용했지만, 람다를 이용해서 다양한 방식으로 파일을 처리할 수 있도록 파라미터화되었음
```java
String oneLine = processFile((BufferedReader b) -> b.readLine());   //람다 전달
String twoLines = processFile((BufferedReader b) -> b.readLine() + b.readLine());   //다른 람다 전달

public static String processFile(BufferedReaderProcessor p) throws IOException {
    try (BufferedReader br = new BufferedReader(new
            FileReader("ModernJavaInAction/chap9/data.txt"))) {
        return p.process(br);   //인수로 전달된 BufferedReaderProcessor를 실행
    }
} //IOException을 던질 수 있는 람다의 함수형 인터페이스

public interface BufferedReaderProcessor {
    String process(BufferedReader b) throws IOException;
}
```

## 9-2. 람다로 객체지향 디자인 패턴 리팩터링하기
### 1. 전략(Strategy) 패턴

### 2. 템플릿 메서드 패턴

### 3. 옵저버 패턴

### 4. 의무 체인 패턴

### 5. 팩토리 패턴

## 9-3. 람다 테스팅
### 1. 보이는 람다 표현식의 동작 테스팅

### 2. 람다를 사용하는 메서드의 동작에 집중하라

### 3. 복잡한 람다를 개별 메서드로 분할하기

### 4. 고차원 함수 테스팅

## 9-4. 디버깅
### 1. 스택 트레이스 확인

### 2. 정보 로깅

